# 최단 경로
## 목차
1. [Dijkstra](#Dijkstra)

2. [Bellman-Ford](#Bellman-Ford)

3. [Floyd-Warshall](#Floyd-Warshall)

## Dijkstra

### 로직

- 힙에 시작점 추가(최단 거리 0)
- 힙에서 pop 한 점의 인접 점 최단 거리 갱신
  
  갱신 조건 $\to$ 현재 점을 거치는 경우 최단 거리가 더 짧으면

- 갱신한 점 힙에 push
- 힙 빌때까지 반복

### 코드

```cpp
#include <bits/stdc++.h>
#define inf 1000000000
using namespace std;
int n,m,k;
priority_queue<vector<int>> q;
vector<vector<int>> edge[20001];
int dist[20001];

void init(){
	cin>>n>>m>>k;
	while(m--){
		int s,e,c;
		cin>>s>>e>>c;
		edge[s].push_back({e,c});
	}
	for(int i=1; i<=n; i++) dist[i]=inf;
	dist[k]=0;
	q.push({0,k});
}

void dijkstra(){
	while(!q.empty()){
		int now=q.top()[1];
		q.pop();
		for(vector<int> e: edge[now]){
			if(dist[e[0]]>dist[now]+e[1]){
				dist[e[0]]=dist[now]+e[1];
				q.push({-dist[e[0]],e[0]});
			}
		}
	}
	for(int i=1; i<=n; i++){
		if(dist[i]==inf) cout<<"INF ";
		else cout<<dist[i]<<" ";
	}
}

int main(){
	init();
	dijkstra();
}
```

### 연습문제

- [1753_최단경로](https://github.com/iacobuschoi/ps/blob/d16ed93d3cae3a1b449b9a3387b2f81d85c2701a/1753_%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C.md)
- [1162_도로포장](https://github.com/iacobuschoi/ps/blob/29ed2aaf2693770a081f3c9cf10b3a61ed159864/1162_%EB%8F%84%EB%A1%9C%ED%8F%AC%EC%9E%A5.md)
- 

## Bellman-Ford

## Floyd-Warshall
